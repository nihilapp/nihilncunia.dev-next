---
alwaysApply: true
---

# API 및 서비스 레이어 규칙

---

## API 라우트 구조

### 기본 구조

- 모든 API는 `/app/api` 폴더 안에 작성합니다.
- API 라우트는 `route.ts` 파일로 작성합니다.
- HTTP 메서드별로 함수를 분리합니다 (GET, POST, PUT, DELETE).

### 폴더 구조 예시

```
app/api/
├── auth/
│   ├── signin/
│   │   └── route.ts
│   ├── signup/
│   │   └── route.ts
│   └── logout/
│       └── route.ts
├── users/
│   ├── route.ts
│   └── [id]/
│       └── route.ts
└── posts/
    ├── route.ts
    └── [id]/
        └── route.ts
```

## API Import 구조

### 필수 Import 규칙

- 반드시 'NextRequest', 'NextResponse'를 'next/server'에서 import 합니다.
- Supabase 클라이언트는 '@/\_libs/supabase'에서 'serverClient'를 import 합니다.
- 'SuccessPayload', 'ErrorPayload' 타입은 '@/\_entities/common'에서 import 합니다.
- 엔티티별 타입들은 '@/\_entities/[entity명]'에서 import 합니다.
- 'successResponse', 'errorResponse' 함수는 '@/\_libs/responseHelper'에서 import 합니다.

### 공통 유틸리티 Import

공통 유틸리티는 '@/tools'에서 개별적으로 import 합니다:

- 'AxiosHelper' from '@/tools/axios.tools'
- 'BcryptHelper' from '@/tools/bcrypt.tools'
- 'CommonHelper' from '@/tools/common.tools'
- 'CookieHelper' from '@/tools/cookie.tools'
- 'DateTools' from '@/tools/date.tools'
- 'Logger' from '@/tools/logger.tools'

### Import 예시

```typescript
import { NextRequest, NextResponse } from "next/server";

import { serverClient } from "@/_libs/supabase";
import { SuccessPayload, ErrorPayload } from "@/_entities/common";
import { User, CreateUser } from "@/_entities/users/users.types";
import { successResponse, errorResponse } from "@/_libs/responseHelper";
import { BcryptHelper } from "@/tools/bcrypt.tools";
import { Logger } from "@/tools/logger.tools";
```

## API 응답 형식

### 응답 함수 사용

- 성공 응답은 'successResponse' 함수를 사용합니다.
- 에러 응답은 'errorResponse' 함수를 사용합니다.

### 응답 구조

- 성공 응답 구조: `{ data: T, status: number }`
- 에러 응답 구조: `{ status: number, message: string }`

### 응답 함수 사용 예시

```typescript
// 성공 응답
return successResponse({ data: result, status: 200 });

// 에러 응답
return errorResponse({ status: 400, message: "잘못된 요청입니다." });
```

## 에러 처리

### HTTP 상태코드 규칙

- 모든 API는 try-catch로 감싸야 합니다.
- 요청 데이터 파싱 에러는 400 상태코드로 처리합니다.
- 인증 관련 에러는 401 상태코드로 처리합니다.
- 데이터 없음은 404 상태코드로 처리합니다.
- 중복 데이터는 409 상태코드로 처리합니다.
- 서버 에러는 500 상태코드로 처리합니다.

### 에러 처리 예시

```typescript
export async function POST(request: NextRequest) {
  try {
    const body = await request.json();

    if (!body.email) {
      return errorResponse({ status: 400, message: "이메일이 필요합니다." });
    }

    const result = await UserService.create(body);
    return successResponse({ data: result, status: 201 });
  } catch (error) {
    Logger.error("User creation failed:", error);
    return errorResponse({ status: 500, message: "서버 오류가 발생했습니다." });
  }
}
```

## 서비스 레이어 구조

### 서비스 파일 규칙

- 데이터베이스 관련 로직은 각 엔티티의 service 파일에 위치한다.
- service 파일은 `@/_entities/[entity명]/[entity명].service.ts` 형태로 작성한다.
- Prisma 클라이언트는 `@/_libs/tools/prisma.tools`에서 PrismaHelper.client로 접근한다.
- API 라우트에서는 service 파일을 직접 import하여 사용한다.

### 서비스 파일 예시

```typescript
// users.service.ts
import { PrismaHelper } from "@/_libs/tools/prisma.tools";
import type { CreateUser, User } from "./users.types";

export class UserService {
  static async create(userData: CreateUser): Promise<User> {
    const newUser = await PrismaHelper.client.user.create({
      data: userData,
    });
    return newUser;
  }

  static async findById(id: string): Promise<User | null> {
    const findUser = await PrismaHelper.client.user.findUnique({
      where: { id },
    });
    return findUser;
  }
}

// route.ts
import { UserService } from "@/_entities/users/users.service";

export async function POST(request: NextRequest) {
  const userData = await request.json();
  const result = await UserService.create(userData);
  return successResponse({ data: result, status: 201 });
}
```

## Supabase DB 사용 규칙

### 클라이언트 생성

- API 라우트에서만 Supabase를 사용하여 데이터베이스를 조작합니다.
- 'serverClient(request)' 함수로 Supabase 클라이언트를 생성합니다.

### 데이터 조회 규칙

- 조회시 필요한 필드만 'select'를 사용하여 선택합니다.
- 'find'로 시작하는 변수명을 사용하여 데이터 존재 여부를 확인합니다.
- 조회된 데이터는 'find'로 시작합니다. (예: findUser, findPost)
- 생성/수정된 데이터는 'new', 'updated'를 접두사로 사용합니다.

### 요청 데이터 변수명

- 요청 데이터를 받는 변수는 의미있는 이름을 사용합니다. (예: userData, updateData, passwordData)

### Supabase 사용 예시

```typescript
export async function GET(request: NextRequest) {
  const { client } = serverClient(request);

  const { data: findUser } = await client
    .from("users")
    .select("id, email, name")
    .eq("id", userId)
    .single();

  if (!findUser) {
    return errorResponse({
      status: 404,
      message: "사용자를 찾을 수 없습니다.",
    });
  }

  return successResponse({ data: findUser, status: 200 });
}
```

## Params 처리

### 동적 라우트 Params

- 동적 라우트의 params는 'Promise' 타입입니다.
- 'interface Params { params: Promise<{id: string}> }' 형식으로 정의합니다.
- 'const { id } = await params;' 형식으로 비동기 처리합니다.

### Params 처리 예시

```typescript
interface Params {
  params: Promise<{ id: string }>;
}

export async function GET(request: NextRequest, { params }: Params) {
  const { id } = await params;

  const findUser = await UserService.findById(id);
  if (!findUser) {
    return errorResponse({
      status: 404,
      message: "사용자를 찾을 수 없습니다.",
    });
  }

  return successResponse({ data: findUser, status: 200 });
}
```

## 보안 규칙

### 비밀번호 처리

- 비밀번호는 'BcryptHelper.dataToHash()' 함수로 해싱합니다.
- 비밀번호 검증은 'BcryptHelper.dataCompare()' 함수를 사용합니다.

### 권한 확인

- 사용자 권한 확인을 통해 본인의 데이터만 수정/삭제 가능하도록 합니다.
- 민감한 정보는 응답에서 제외합니다. (비밀번호, 토큰 등)

### 보안 예시

```typescript
export async function POST(request: NextRequest) {
  const { email, password } = await request.json();

  // 비밀번호 해싱
  const hashedPassword = await BcryptHelper.dataToHash(password);

  const newUser = await UserService.create({
    email,
    password: hashedPassword,
  });

  // 응답에서 비밀번호 제외
  const { password: _, ...userWithoutPassword } = newUser;

  return successResponse({ data: userWithoutPassword, status: 201 });
}
```

## Prisma 사용시

### 모델 규칙

- 'model' 은 대문자로 시작합니다.
- 각 모델은 '@@map'을 해서 소문자, 스네이크 케이스로 매핑합니다.
- 각 모델은 'uuid'를 아이디로 사용합니다. 또한 자동으로 생성되게 합니다.
- 관계 설정시에는 'delete' 를 'cascade' 로 설정합니다.
- 각 모델의 각 컬럼의 이름은 스네이크 케이스로 작성합니다.

### Prisma 스키마 예시

```prisma
model User {
  id        String   @id @default(cuid()) @map("id")
  email     String   @unique @map("email")
  password  String   @map("password")
  name      String?  @map("name")
  created_at DateTime @default(now()) @map("created_at")
  updated_at DateTime @updatedAt @map("updated_at")

  posts Post[] @relation("UserPosts")

  @@map("users")
}

model Post {
  id         String   @id @default(cuid()) @map("id")
  title      String   @map("title")
  content    String   @map("content")
  user_id    String   @map("user_id")
  created_at DateTime @default(now()) @map("created_at")
  updated_at DateTime @updatedAt @map("updated_at")

  user User @relation("UserPosts", fields: [user_id], references: [id], onDelete: Cascade)

  @@map("posts")
}
```

---

> 이 규칙은 Next.js API, 데이터베이스, 인증, 보안 등 백엔드 개발의 일관성과 안전성을 보장하기 위한 가이드입니다.
